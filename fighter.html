<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fighter</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>⚔️</text></svg>">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Kanit:ital,wght@1,900&display=swap');

        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Kanit', sans-serif; }
        canvas { display: block; }
        
        #ui {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 100px;
            pointer-events: none;
            user-select: none;
        }

        .player-card {
            text-align: center;
            min-width: 120px;
        }

        .percent { 
            font-size: 5rem; 
            font-weight: 900; 
            font-style: italic;
            line-height: 1;
            text-shadow: 
                -3px -3px 0 #000,  
                 3px -3px 0 #000,
                -3px  3px 0 #000,
                 3px  3px 0 #000,
                 8px  8px 0 #000; 
        }

        #p1-percent { color: #ff3333; }
        #p2-percent { color: #3333ff; }

        .name { 
            font-size: 1.5rem; 
            color: white; 
            font-weight: 900;
            margin-top: -5px;
            text-shadow: 
                -2px -2px 0 #000,  
                 2px -2px 0 #000,
                -2px  2px 0 #000,
                 2px  2px 0 #000,
                 4px  4px 0 #000;
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 8px;
            font-size: 0.85rem;
            line-height: 1.4;
            font-family: sans-serif;
            z-index: 10;
        }
        .key-hint { background: #444; padding: 2px 6px; border-radius: 4px; font-family: monospace; }
        
        .toggle-container {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            pointer-events: auto;
        }
    </style>
</head>
<body>

    <div id="instructions">
        <p><strong>P1 (Red):</strong> <span class="key-hint">S/T</span> L/R, <span class="key-hint">R/H</span> U/D, <span class="key-hint">Space</span> Jump</p>
        <p><strong>Attacks:</strong> <span class="key-hint">N</span> Light, <span class="key-hint">E</span> Heavy, <span class="key-hint">O</span> Special</p>
        
        <label class="toggle-container">
            <input type="checkbox" id="hitbox-toggle">
            <span>Show Hitboxes</span>
        </label>
    </div>

    <div id="ui">
        <div class="player-card" id="p1-card">
            <div class="percent" id="p1-percent">0%</div>
            <div class="name">P1</div>
        </div>
        <div class="player-card" id="p2-card">
            <div class="percent" id="p2-percent">0%</div>
            <div class="name">CPU</div>
        </div>
    </div>

    <script>
        const STAGE_WIDTH = 24;
        const STAGE_HEIGHT = 2;
        const GRAVITY = -0.03;
        const TERMINAL_VELOCITY = -0.85; 
        const GROUND_FRICTION = 0.82; 
        const AIR_FRICTION = 0.985;   
        const BLAST_ZONE_X = 40;
        const BLAST_ZONE_Y = 30;
        const MAX_WALK_SPEED = 0.20;  
        const MAX_AIR_CONTROL = 0.12; 
        const MOVE_ACCEL_GROUND = 0.04;
        const MOVE_ACCEL_AIR = 0.016;
        const HITSTUN_CONTROL_MULT = 0.4;
        const HITSTUN_LOCKOUT = 15;    
        const KB_COEFFICIENT = 0.01; 

        let scene, camera, renderer;
        let players = [];
        let keys = {};
        let effects = []; 
        let globalHitstop = 0; 
        let showHitboxes = false; // Set hitboxes to off by default

        const DOWN_SPECIAL_SQUASH = new THREE.Vector3(1.6, 0.35, 1.6);

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 40);
            camera.lookAt(0, 2, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(10, 20, 10);
            sun.castShadow = true;
            scene.add(sun);

            const stageGeo = new THREE.BoxGeometry(STAGE_WIDTH, STAGE_HEIGHT, 8);
            const stageMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
            const stage = new THREE.Mesh(stageGeo, stageMat);
            stage.receiveShadow = true;
            scene.add(stage);

            players.push(createPlayer(0xff3333, -5, "p1", false));
            players.push(createPlayer(0x3333ff, 5, "p2", true));

            document.getElementById('hitbox-toggle').addEventListener('change', (e) => {
                showHitboxes = e.target.checked;
            });

            window.addEventListener('keydown', e => {
                const code = e.code;
                players.forEach(p => {
                    if (p.isAI || globalHitstop > 0) return;
                    if (code === 'Space' && p.hitstun <= 0 && p.recoveryFrames <= 0) performJump(p, keys['KeyS'], keys['KeyT']);
                    
                    const isAttackKey = (code === 'KeyN' || code === 'KeyE' || code === 'KeyO');
                    if (isAttackKey && !p.attacking && p.hitstun <= 0 && p.recoveryFrames <= 0) {
                        const dir = {
                            x: (keys['KeyT'] ? 1 : (keys['KeyS'] ? -1 : 0)),
                            y: (keys['KeyR'] ? 1 : (keys['KeyH'] ? -1 : 0))
                        };
                        let type = 'light';
                        if (code === 'KeyE') type = 'heavy';
                        if (code === 'KeyO') type = 'special';
                        
                        handleAttackInput(p, dir, type);
                    }
                });
                keys[code] = true;
            });
            
            window.addEventListener('keyup', e => keys[e.code] = false);
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function createPlayer(color, startX, id, isAI) {
            const group = new THREE.Group();
            
            const visualPivot = new THREE.Group();
            visualPivot.position.y = -0.9; 
            group.add(visualPivot);

            const visualBody = new THREE.Group();
            visualBody.position.y = 0.9; 
            visualPivot.add(visualBody);

            const bodyGeo = new THREE.BoxGeometry(1.2, 1.8, 1.2);
            const bodyMat = new THREE.MeshPhongMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.castShadow = true;
            visualBody.add(body);

            const eyeGeo = new THREE.BoxGeometry(0.8, 0.2, 0.2);
            const eyeMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const eyes = new THREE.Mesh(eyeGeo, eyeMat);
            eyes.position.set(0, 0.4, 0.61);
            visualBody.add(eyes);

            const hitboxContainer = new THREE.Group();
            group.add(hitboxContainer);

            scene.add(group);

            return {
                id: id,
                isAI: isAI,
                mesh: group,
                visualPivot: visualPivot, 
                visualBody: visualBody,
                bodyMesh: body,
                baseColor: new THREE.Color(color),
                hitboxContainer: hitboxContainer,
                color: color,
                velocity: new THREE.Vector3(),
                pos: new THREE.Vector3(startX, 5, 0),
                percent: 0,
                isGrounded: false,
                jumpsUsed: 0,
                specialUsed: false, 
                recoveryFrames: 0, 
                inFreefall: false, 
                heavyLanding: false, 
                facing: (startX < 0 ? 1 : -1),
                attacking: false,
                attackSubtype: null,
                currentAttack: null, 
                hitstun: 0,
                hitstunMax: 0, 
                width: 1.2,
                height: 1.8
            };
        }

        function performJump(p, moveLeft, moveRight) {
            if (p.isGrounded) {
                p.velocity.y = 0.51; 
                p.isGrounded = false;
                p.jumpsUsed = 1;
            } else if (p.jumpsUsed < 2) {
                p.velocity.y = 0.47;
                p.jumpsUsed = 2;
                if (moveLeft) p.velocity.x = -0.15;
                if (moveRight) p.velocity.x = 0.15;
            }
        }

        function spawnFlameParticle(player) {
            const geo = new THREE.SphereGeometry(0.6, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xff5500, transparent: true, opacity: 0.8 });
            const flame = new THREE.Mesh(geo, mat);
            flame.position.copy(player.pos).add(new THREE.Vector3((Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5));
            scene.add(flame);
            effects.push({
                mesh: flame, life: 1.0, 
                update: function(dt) {
                    this.life -= dt * 2.5;
                    this.mesh.scale.setScalar(this.life * 2.0);
                    this.mesh.position.y += 0.05;
                    this.mesh.material.opacity = this.life;
                    if (this.life <= 0) { scene.remove(this.mesh); return false; }
                    return true;
                }
            });
        }

        function createSpecialVFX(type, player) {
            if (type === 'neutral') {
                for (let i = 0; i < 6; i++) {
                    const points = [];
                    let lastPt = new THREE.Vector3(0, 0, 0);
                    points.push(lastPt.clone());
                    for (let j = 1; j < 8; j++) {
                        lastPt = new THREE.Vector3(
                            j * player.facing * 1.3, 
                            (Math.random() - 0.5) * 1.8,
                            (Math.random() - 0.5) * 1
                        );
                        points.push(lastPt.clone());
                    }
                    const geo = new THREE.BufferGeometry().setFromPoints(points);
                    const mat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 1.0 });
                    const line = new THREE.Line(geo, mat);
                    player.mesh.add(line);
                    effects.push({
                        mesh: line, life: 1.0, update: function(dt) {
                            this.life -= dt * 4.5;
                            this.mesh.material.opacity = this.life;
                            if (this.life <= 0) { player.mesh.remove(this.mesh); return false; }
                            return true;
                        }
                    });
                }
            } else if (type === 'down') {
                for (let i = 0; i < 12; i++) {
                    const geo = new THREE.IcosahedronGeometry(Math.random() * 0.4 + 0.2, 0);
                    const mat = new THREE.MeshPhongMaterial({ color: 0x665544 });
                    const rock = new THREE.Mesh(geo, mat);
                    rock.position.set(
                        player.pos.x + (Math.random() - 0.5) * 6,
                        player.pos.y - 1,
                        (Math.random() - 0.5) * 2
                    );
                    scene.add(rock);
                    effects.push({
                        mesh: rock, life: 1.0,
                        vel: new THREE.Vector3((Math.random() - 0.5) * 0.1, 0.15 + Math.random() * 0.25, (Math.random() - 0.5) * 0.1),
                        update: function(dt) {
                            this.life -= dt * 2.5;
                            this.mesh.position.add(this.vel);
                            this.vel.y -= 0.02;
                            this.mesh.rotation.x += 0.2;
                            this.mesh.scale.setScalar(this.life);
                            if (this.life <= 0) { scene.remove(this.mesh); return false; }
                            return true;
                        }
                    });
                }
            } else if (type === 'up') {
                let spawnCount = 0;
                const totalSpawns = 8;
                const interval = setInterval(() => {
                    if (spawnCount >= totalSpawns) {
                        clearInterval(interval);
                        return;
                    }
                    spawnFlameParticle(player);
                    spawnCount++;
                }, 40);
            }
        }

        function handleAttackInput(player, dir, type) {
            player.attacking = true;
            const attackDirY = dir.y;

            let attackConfig = {
                startup: 0,
                activeFrames: 10,
                range: 2.0,
                damage: 5,
                knockback: 10,
                angle: 60,
                offset: new THREE.Vector3(1.2, 0, 0), 
                type: type,
                subtype: 'normal',
                hasHit: false,
                visuals: [], 
                isMultiHitbox: false,
                isRecoveryMove: false
            };

            if (type === 'special') {
                if (attackDirY === 1) {
                    if (player.specialUsed) { player.attacking = false; return; }
                    player.specialUsed = true;
                    player.inFreefall = true; 
                    
                    // Delay the flight and VFX for the startup
                    attackConfig.startup = 200; // Increased startup from 50 to 200
                    attackConfig.damage = 8;
                    attackConfig.knockback = 12;
                    attackConfig.angle = 90;
                    attackConfig.range = 2.4;
                    attackConfig.offset.set(0, 0, 0);
                    attackConfig.activeFrames = 15;
                    attackConfig.isRecoveryMove = true;
                    player.recoveryFrames = 80; 

                    // Store movement intent for when startup finishes
                    const moveX = dir.x;
                    setTimeout(() => {
                        if (player.hitstun > 0 || globalHitstop > 0) return;
                        createSpecialVFX('up', player);
                        const horizontalShift = 0.28; 
                        if (moveX !== 0) {
                            player.velocity.x = moveX * horizontalShift;
                            player.facing = moveX;
                        }
                        player.velocity.y = 0.85; 
                    }, attackConfig.startup);

                } else if (attackDirY === -1) {
                    attackConfig.subtype = 'down-special';
                    player.attackSubtype = 'down-special';
                    attackConfig.startup = 600; 
                    attackConfig.damage = 18;
                    attackConfig.knockback = 15;
                    attackConfig.angle = 45;
                    attackConfig.range = 0.64; 
                    attackConfig.offset.set(0, 0, 0);
                    attackConfig.activeFrames = 15;
                    attackConfig.isMultiHitbox = true; 
                    // Immediately squash
                    player.visualPivot.scale.copy(DOWN_SPECIAL_SQUASH); 
                } else {
                    attackConfig.startup = 120;
                    attackConfig.damage = 2;
                    attackConfig.knockback = 3;
                    attackConfig.angle = 30;
                    attackConfig.activeFrames = 12;
                    attackConfig.isMultiHitbox = true;
                }
            } else if (player.isGrounded) {
                if (type === 'light') {
                    attackConfig.startup = 50; attackConfig.damage = 3; attackConfig.knockback = 5; attackConfig.activeFrames = 8;
                    if (attackDirY === 1) { attackConfig.angle = 80; attackConfig.offset.set(0, 1.2, 0); attackConfig.range = 1.2; }
                    else if (attackDirY === -1) { attackConfig.angle = 30; attackConfig.offset.set(1.0, -0.6, 0); attackConfig.range = 1.8; }
                    else { attackConfig.angle = 60; attackConfig.offset.set(1.2, 0, 0); attackConfig.range = 1.4; }
                } else { 
                    attackConfig.startup = 250; attackConfig.damage = 14; attackConfig.knockback = 7; attackConfig.activeFrames = 18;
                    if (attackDirY === 1) { attackConfig.angle = 60; attackConfig.offset.set(0, 1.8, 0); attackConfig.range = 1.6; }
                    else if (attackDirY === -1) { attackConfig.startup = 320; attackConfig.angle = 45; attackConfig.offset.set(1.0, -0.6, 0); attackConfig.range = 1.5; }
                    else { attackConfig.angle = 45; attackConfig.offset.set(1.4, 0, 0); attackConfig.range = 1.7; }
                }
            } else {
                attackConfig.type = 'light'; attackConfig.activeFrames = 12; attackConfig.startup = 40; attackConfig.damage = 4; attackConfig.knockback = 4;
                if (attackDirY === 1) { attackConfig.startup = 60; attackConfig.damage = 11; attackConfig.angle = 90; attackConfig.offset.set(0, 0.8, 0); attackConfig.range = 1.2; }
                else if (attackDirY === -1) { attackConfig.angle = 30; attackConfig.offset.set(0, -1.2, 0); attackConfig.range = 1.4; }
                else { attackConfig.angle = 60; attackConfig.offset.set(0.8, 0, 0); attackConfig.range = 1.5; }
            }

            if (type !== 'special') {
                if (type === 'light' || !player.isGrounded) player.visualPivot.scale.set(0.9, 1.1, 0.9);
                else player.visualPivot.scale.set(0.75, 1.3, 0.75);
            }

            setTimeout(() => {
                if (player.hitstun > 0 || globalHitstop > 0 || !player.attacking) return;
                
                // Only reset scale if NOT doing down special
                if (player.attackSubtype !== 'down-special') {
                    player.visualPivot.scale.set(1, 1, 1);
                }
                
                const isHeavyGround = (type === 'heavy' && player.isGrounded);
                const isSpecial = (type === 'special');
                const hitColor = isSpecial ? 0x00ff88 : (isHeavyGround ? 0xff0000 : 0xffff00);
                
                if (isSpecial) {
                    if (attackDirY === 0) createSpecialVFX('neutral', player);
                    if (attackDirY === -1) createSpecialVFX('down', player);
                    // Up special VFX is handled separately in its specific block
                }

                if (attackConfig.isMultiHitbox) {
                    if (type === 'special' && attackDirY === -1) {
                        const sideOffsets = [0, -1.5, -3.0, 1.5, 3.0];
                        sideOffsets.forEach(xOffset => {
                            const bSize = attackConfig.range;
                            const geo = new THREE.SphereGeometry(bSize, 12, 12);
                            const mat = new THREE.MeshBasicMaterial({ color: hitColor, transparent: true, opacity: showHitboxes ? 0.4 : 0.0, depthWrite: false });
                            const bubble = new THREE.Mesh(geo, mat);
                            bubble.userData = { range: bSize };
                            bubble.position.set(xOffset, -0.8, 0);
                            player.hitboxContainer.add(bubble);
                            attackConfig.visuals.push(bubble);
                        });
                    } else {
                        for (let i = 0; i < 6; i++) {
                            const bSize = 0.45;
                            const geo = new THREE.SphereGeometry(bSize, 8, 8);
                            const mat = new THREE.MeshBasicMaterial({ color: hitColor, transparent: true, opacity: showHitboxes ? 0.4 : 0.0, depthWrite: false });
                            const bubble = new THREE.Mesh(geo, mat);
                            bubble.userData = { range: bSize };
                            bubble.position.set((1.5 + i * 1.4) * player.facing, 0, 0);
                            player.hitboxContainer.add(bubble);
                            attackConfig.visuals.push(bubble);
                        }
                    }
                } else {
                    const geo = new THREE.SphereGeometry(attackConfig.range, 16, 16);
                    const mat = new THREE.MeshBasicMaterial({ color: hitColor, transparent: true, opacity: showHitboxes ? 0.4 : 0.0, depthWrite: false });
                    const visualMesh = new THREE.Mesh(geo, mat);
                    visualMesh.position.set(attackConfig.offset.x * player.facing, attackConfig.offset.y, attackConfig.offset.z);
                    player.hitboxContainer.add(visualMesh);
                    attackConfig.visuals.push(visualMesh);
                }
                player.currentAttack = attackConfig;
            }, attackConfig.startup);
        }

        function clearAttack(player) {
            if (player.currentAttack) {
                player.currentAttack.visuals.forEach(v => player.hitboxContainer.remove(v));
            }
            player.attacking = false;
            player.currentAttack = null;
            player.attackSubtype = null;
            player.visualPivot.scale.set(1, 1, 1);
        }

        const worldHitboxPos = new THREE.Vector3();
        function checkHit(player, config) {
            if (!config || config.hasHit || config.visuals.length === 0) return;
            const opponent = players.find(p => p !== player);
            const minX = opponent.pos.x - 0.6, maxX = opponent.pos.x + 0.6;
            const minY = opponent.pos.y - 0.9, maxY = opponent.pos.y + 0.9;

            for (const visual of config.visuals) {
                visual.getWorldPosition(worldHitboxPos);
                const currentRange = config.isMultiHitbox ? visual.userData.range : config.range;
                const closestX = Math.max(minX, Math.min(worldHitboxPos.x, maxX));
                const closestY = Math.max(minY, Math.min(worldHitboxPos.y, maxY));
                const dx = worldHitboxPos.x - closestX, dy = worldHitboxPos.y - closestY;
                if ((dx * dx + dy * dy) < (currentRange * currentRange) && opponent.hitstun <= 0) {
                    config.hasHit = true; 
                    const kbDir = opponent.pos.x - player.pos.x > 0 ? 1 : -1;
                    const pctFactor = Math.min(1, opponent.percent / 100);
                    globalHitstop = (config.type === 'light') ? 2 + Math.floor(8 * pctFactor) : 10 + Math.floor(15 * pctFactor);
                    applyHit(opponent, kbDir, config);
                    if (showHitboxes) config.visuals.forEach(v => v.material.opacity = 0.8);
                    break; 
                }
            }
        }

        function applyHit(victim, xDir, config) {
            victim.percent += config.damage;
            const percentEl = document.getElementById(`${victim.id}-percent`);
            if (percentEl) percentEl.innerText = victim.percent + "%";
            const rad = config.angle * (Math.PI / 180);
            const knockbackScaling = config.type === 'special' ? 0.004 : 0.012;
            const forceMultiplier = 1.0 + (victim.percent * knockbackScaling);
            const totalForce = config.knockback * KB_COEFFICIENT * forceMultiplier;
            victim.velocity.x = Math.cos(rad) * xDir * totalForce * 6;
            victim.velocity.y = Math.sin(rad) * totalForce * 6;
            const baseHitstun = (config.type === 'heavy' || config.type === 'special') ? 12 : 5;
            victim.hitstun = Math.min(60, baseHitstun + (victim.percent * 0.08));
            victim.hitstunMax = victim.hitstun;
            victim.isGrounded = false;
            victim.recoveryFrames = 0; 
            victim.inFreefall = false; 
            victim.heavyLanding = false;
            if (victim.attacking) clearAttack(victim);
            victim.visualBody.children[0].material.emissive.setHex(0xffffff);
            setTimeout(() => victim.visualBody.children[0].material.emissive.setHex(0x000000), 100);
        }

        function createKOEffect(pos, color) {
            const geo = new THREE.SphereGeometry(5, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 1.0 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            scene.add(mesh);
            effects.push({
                mesh, life: 1.0,
                update: function(dt) {
                    this.life -= dt * 1.5;
                    this.mesh.scale.multiplyScalar(1.2);
                    this.mesh.material.opacity = this.life;
                    if (this.life <= 0) { scene.remove(this.mesh); return false; }
                    return true;
                }
            });
        }

        function handleInput() {
            if (globalHitstop > 0) return;
            players.forEach(p => {
                if (p.attacking && p.attackSubtype === 'down-special') return;
                if (p.attacking && p.isGrounded) return;
                if (p.recoveryFrames > 0) return; 
                let moveLeft = p.isAI ? (p.pos.x > (STAGE_WIDTH/2) || p.pos.x > 2) : keys['KeyS'];
                let moveRight = p.isAI ? (p.pos.x < -(STAGE_WIDTH/2) || p.pos.x < -2) : keys['KeyT'];
                let accel = p.isGrounded ? MOVE_ACCEL_GROUND : MOVE_ACCEL_AIR;
                let max = p.isGrounded ? MAX_WALK_SPEED : MAX_AIR_CONTROL;
                if (p.hitstun > 0) {
                    const elapsed = p.hitstunMax - p.hitstun;
                    if (elapsed < HITSTUN_LOCKOUT) { accel = 0; max = 0; }
                    else { accel *= HITSTUN_CONTROL_MULT; max *= HITSTUN_CONTROL_MULT; }
                }
                if (moveLeft) { p.velocity.x -= accel; p.facing = -1; }
                if (moveRight) { p.velocity.x += accel; p.facing = 1; }
                if (Math.abs(p.velocity.x) > max && p.hitstun <= 0) p.velocity.x = THREE.MathUtils.lerp(p.velocity.x, Math.sign(p.velocity.x) * max, 0.2);
            });
        }

        function updatePhysics(dt) {
            effects = effects.filter(fx => fx.update(dt));
            if (globalHitstop > 0) {
                globalHitstop--;
                players.forEach(p => { 
                    if (p.hitstun > 0) p.visualBody.position.y = 0.9 + (Math.random()-0.5)*0.3; 
                    else p.visualBody.position.y = 0.9;
                });
                return;
            }
            players.forEach(p => {
                p.visualBody.position.y = 0.9;
                
                // --- Visual State Handling ---
                // PRIORITY 1: Special Attacks that force scale
                if (p.attacking && p.attackSubtype === 'down-special') {
                    p.visualPivot.scale.copy(DOWN_SPECIAL_SQUASH);
                } 
                // PRIORITY 2: Recovery / Lag States
                else if (p.recoveryFrames > 0) { 
                    p.recoveryFrames--; 
                    if (p.isGrounded) {
                        if (p.heavyLanding) {
                            const lagColor = p.baseColor.clone().multiplyScalar(0.4);
                            p.bodyMesh.material.color.lerp(lagColor, 0.2);
                            p.visualPivot.scale.lerp(new THREE.Vector3(1.3, 0.7, 1.3), 0.5);
                        } else {
                            p.bodyMesh.material.color.lerp(p.baseColor, 0.2);
                            p.visualPivot.scale.lerp(new THREE.Vector3(1.2, 0.8, 1.2), 0.5);
                        }
                    } else {
                        p.bodyMesh.material.color.lerp(p.baseColor, 0.1);
                        p.visualPivot.scale.lerp(new THREE.Vector3(0.85, 1.15, 0.85), 0.2);
                    }
                } 
                // PRIORITY 3: Idle / Normal movement
                else if (!p.attacking) { 
                    p.bodyMesh.material.color.lerp(p.baseColor, 0.1);
                    p.visualPivot.scale.lerp(new THREE.Vector3(1, 1, 1), 0.15); 
                }

                if (p.currentAttack) {
                    checkHit(p, p.currentAttack);
                    p.currentAttack.activeFrames--;
                    p.currentAttack.visuals.forEach(v => v.material.opacity = showHitboxes ? Math.max(0.1, v.material.opacity * 0.95) : 0);
                    if (p.currentAttack.activeFrames <= 0) clearAttack(p);
                }
                if (p.hitstun > 0) p.hitstun--;
                
                p.velocity.y = Math.max(TERMINAL_VELOCITY, p.velocity.y + GRAVITY);
                p.pos.add(p.velocity);
                p.velocity.x *= p.isGrounded ? GROUND_FRICTION : AIR_FRICTION;
                
                const halfW = STAGE_WIDTH / 2;
                if (Math.abs(p.pos.x) < halfW + 0.6) {
                    const groundLevel = 1 + (p.height / 2);
                    if (p.pos.y <= groundLevel && p.pos.y > 0 && p.velocity.y <= 0) {
                        const fellIntoGround = !p.isGrounded;
                        p.pos.y = groundLevel; 
                        p.velocity.y = 0;
                        if (fellIntoGround) { 
                            p.isGrounded = true; 
                            p.jumpsUsed = 0; 
                            p.specialUsed = false; 
                            
                            // LANDING LOGIC
                            if (p.attacking && p.attackSubtype === 'down-special') {
                                p.inFreefall = false;
                                p.heavyLanding = false;
                            } else if (p.inFreefall) {
                                p.recoveryFrames = 20; 
                                p.heavyLanding = true;
                                p.inFreefall = false; 
                                p.visualPivot.scale.set(1.3, 0.7, 1.3);
                            } else {
                                p.recoveryFrames = 0; 
                                p.heavyLanding = false;
                                p.visualPivot.scale.set(1.2, 0.8, 1.2); 
                            }
                        }
                    } else if (p.pos.y > groundLevel + 0.1) { p.isGrounded = false; }
                } else { p.isGrounded = false; }
                
                if (Math.abs(p.pos.x) > BLAST_ZONE_X || Math.abs(p.pos.y) > BLAST_ZONE_Y) { createKOEffect(p.pos.clone(), p.color); respawn(p); }
                p.mesh.position.copy(p.pos);
                p.visualPivot.rotation.y = THREE.MathUtils.lerp(p.visualPivot.rotation.y, p.facing === 1 ? Math.PI/2 : -Math.PI/2, 0.2);
            });
        }

        function respawn(player) {
            player.pos.set(player.id === 'p1' ? -5 : 5, 12, 0);
            player.velocity.set(0, 0, 0);
            player.percent = 0; player.hitstun = 0; player.hitstunMax = 0;
            player.jumpsUsed = 0; player.specialUsed = false; 
            player.recoveryFrames = 0; player.inFreefall = false; player.heavyLanding = false;
            player.bodyMesh.material.color.copy(player.baseColor);
            if (player.attacking) clearAttack(player);
            document.getElementById(`${player.id}-percent`).innerText = "0%";
        }

        function onWindowResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        const clock = new THREE.Clock();
        function animate() { requestAnimationFrame(animate); handleInput(); updatePhysics(clock.getDelta()); renderer.render(scene, camera); }
        init();
    </script>
</body>
</html>
